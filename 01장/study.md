# 자바 8, 9, 10, 11에서 무슨 일이 일어나고 있는가?

# 1.1 역사의 흐름은 무엇인가?

자바 역사를 통틀어 가장 큰 변화가 자바 8에서 일어났다.

```java
inventory.sort(comparing(Apple::getWeight));
```

위 코드는 사과의 무게를 비교해서 목록에서 정렬한다.

멀티코어 CPU 대중화와 같은 하드웨어적인 변화도 자바8에 영향을 미쳤다.
자바 8이 등장하기 이전에는 나머지 코어를 활용하려면 스레드를 사용하는 것이 좋다고 누군가 조언했을 것이다.
하지만 스레드를 사용하면 관리하기 어렵고 많은 문제가 발생할 수 있다. 자바는 이러한 병렬 실행 환경을 쉽게 관리하고 에러가 덜 발생하는 방향으로 진화하려 노력했다.

자바 8은 간결한 코드, 멀티코어 프로세서의 쉬운 활용이라는 두 가지 요구사항을 기반으로 한다. 자바 8에서 제공하는 새로운 기술이 어떤 것인지 확인하자.

- 스트림 API
- 메서드에 코드를 전달하는 기법
- 인터페이스의 디폴트 메서드

데이터베이스 질의 언어에서 고수준 언어로 원하는 동작을 표현하면, 구현(자바에서는 스트림 라이브러리가 이 역할을 수행)에서 최적의 저수준 실행 방법을 선택하는 방식으로 동작한다. 즉, 스트림을 이용하면 에러를 자주 일으키며 멀티코어 CPU를 이용하는 것보다 비용이 훨씬 비싼 키워드 `synchronized`를 사용하지 않아도 된다.

조금 다른 관점에서 보면 결국 자바 8에 추가된 스트림 API 덕분에 다른 두 가지 기능, 즉 메서드에 코드를 전달하는 간결 기법(메서드 참조와 람다)과 인터페이스의 디폴트 메서드가 존재 할 수 있음을 알 수 있다.

# 1.2 왜 아직도 자바는 변화하는가?

우리는 시공을 초월하는 완벽한 언어를 원하지만 현실적으로는 그런 언어는 존재하지 않으며 모든 언어가 장단점을 갖고 있다. 

## 1.2.1 프로그래밍 언어 생태계에서 자바의 위치

프로그래밍 언어 생태계에 변화의 바람이 불었다. 프로그래머는 빅데이터(테라바이트 이상의 데이터셋) 라는 도전에 직면하면서 멀티코어 컴퓨터나 컴퓨팅 클러스터를 이용해서 빅데이터를 효과적으로 처리할 필요성이 커졌다. 즉, 병렬 프로세싱을 활용해야 하는 데 지금까지의 자바로는 충분히 대응할 수 없었다.

생태계를 요약하자면 새로운 언어가 등장하고 새로운 언어는 변화하는 환경에 빠르게 적응하면서 점점 대중화된다는 것이다.

## 1.2.2 스트림 처리

첫 번째 프로그래밍 개념은 스트림 처리`stream processing` 다. 스트림이란 한 번에 한 개씩 만들어지는 연속적인 데이터 항목들의 모임이다. 이론적으로 프로그램은 입력 스트림에서 데이터를 한 개씩 읽어 들이며 마찬가지로 출력 스트림으로 데이터를 한 개씩 기록한다. 즉, 어떤 프로그램의 출력 스트림은 다른 프로그램의 입력 스트림이 될 수 있다.

스트림 API의 핵심은 기존에는 한 번에 한 항목을 처리했지만 이제 자바 8에서는 우리가 하려는 작업 (데이터베이스 질의처럼) 고수준으로 추상화해서 일련의 스트림으로 만들어 처리할 수 있다는 것이다. 또한 스트림 파이프라인을 이용해서 입력 부분을 여러 CPU 코어에 쉽게 할당할 수 있다는 부가적인 이득도 얻을 수 있다. 스레드라는 복잡한 작업을 사용하지 않으면서도 공짜로 병렬성을 얻을 수 있다.

## 1.2.3 동작 파라미터화로 메서드에 코드 전달하기

자바 8에 추가된 두 번째 프로그램 개념은 코드 일부를 API로 전달하는 기능이다. 자바 8에서는 메서드 (우리 코드)를 다른 메서드의 인수로 넘겨주는 기능을 제공한다. 이러한 기능을 이론적으로 **동작 파라미터화** `behavior parameterization` 라고 부른다. 동작 파라미터가 왜 중요할까? compareUsingCustomerId를 이용해 sort의 동작을 파라미터화했던 것처럼 스트림 API는 연산의 동작을 파라미터화할 수 있는 코드를 전달한다는 사상에 기초하기 때문이다.

## 1.2.4 병렬성과 공유 가변 데이터

세 번째 프로그래밍의 개념은 '병렬성을 공짜로 얻을 수 있다'라는 말에서 시작된다. 세상에 공짜는 없다고 했는데 그럼 병렬성을 얻는 대신 무엇을 포기해야 할까? 스트림 메서드로 전달하는 코드의 동작 방식을 조금 바꿔야 한다.

자바 8 스트림을 이용하면 기존의 자바 스레드 API보다 쉽게 병렬성을 활용할 수 있다. 다중 프로세싱 코어에서 `synchronized`를 사용하면 (다중 처리 코어에서는 코드가 순차적으로 실행되어야 하므로 병렬이라는 목적을 무력화시키면서) 생각보다 훨씬 더 비싼 대가를 치러야 할 수 있다.

## 1.2.5 자바가 진화해야 하는 이유

극단적으로 생각하면 전통적인 객체지향 프로그래밍과 함수형 프로그래밍은 완전 상극이다. 자바 8에서 함수형 프로그래밍을 도입함으로써 두 가지 프로그래밍 패터다임의 장점을 모두 활용할 수 있게 되었다.

언어는 하드웨어나 프로그래머가 기대의 변화에 부응하는 방향으로 변화해야 한다는 것이다.

# 1.3 자바 함수

프로그래밍 언어에서 함수`function` 이라는 용어는 메서드 `method` 특히 정적 메서드 `static method` 와 같은 의미로 사용된다. 자바의 함수는 이에 더해 수학적인 함수처럼 사용되며 부작용을 일으키지 않는 함수를 의미한다. 

프로그래밍 언어의 핵심은 값을 바꾸는 것이다. 역사적으로 그리고 전통적으로 프로그래밍 언어에서는 이 값을 일급`first-class` 값 (또는 시민`citizens`, 1960년대 미국 시민 권리에서 유래)이라고 부른다. 자바 프로그래밍 언어의 다양한 구조체(메서드, 클래스 같은)가 값의 구조를 표현하는 데 도움이 될 수 있다. 하지만 프로그램을 실행하는 동안 이러한 모든 구조체를 자유롭게 전달할 수는 없다. 이렇게 전달할 수 없는 구조체는 이급 시민이다. 위에서 언급한 값은 모두 일급 자바 시민이지만 메서드, 클래스 등은 이급 자바 시민에 해당한다. 인스턴스화한 결과가 값으로 귀결되는 클래스를 정의할 때 메서드를 아주 유용하게 활용할 수 있지만 여전히 메서드와 클래스는 그 자체로 값이 될 수 없다. 

하지만 이게 중요할까? 그렇다. 예를 들어 런타임에 메서드를 전달할 수 있다면, 즉 메서드를 일급 시민으로 만들면 프로그래밍에 유용하게 활용할 수 있다. 따라서 자바 8 설계자들은 이급 시민을 일급 시민으로 바꿀 수 있는 기능을 추가했다.

## 1.3.1 메서드와 람다를 일급 시민으로

새로운 자바 8의 기능 : 메서드 참조 `method reference`

```java
File[] hiddenFiles = new File(".").listFiles(File::isHidden);
```

자바 8에서는 더 이상 메서드가 이급값이 아닌 일급값이라는 것이다. 기존에 객체 참조`object reference`(new 객체 참조를 생성함)를 이용해서 객체를 이리저리 주고받았던 것처럼 자바 8에서는 File::isHidden 을 이용해서 메서드 참조를 만들어 전달할 수 있게 되었다.

### 람다 : 익명 함수

자바 8에서는 (기명`named`) 메서드를 일급값으로 취급할 뿐 아니라 람다(또는 익명 함수`anonymous functions)` 를 포함하여 함수도 값으로 취급할 수 있다. 예를 들어 (int x) -> x + 1, 즉 'x라는 인수로 호출하면 x + 1을 반환'하는 동작을 수행하도록 코드를 구현할 수 있다.

특정 항목을 선택해서 반환하는 동작을 필터`filter`라고 한다.
자바 8에서는 코드를 인수로 넘겨줄 수 있으므로 filter 메서드를 중복으로 구현할 필요가 없다.

before
```java
public static List<Apple> filterHeavyApples(List<Apple> inventory) {  
  List<Apple> result = new ArrayList<>();  
  for (Apple apple : inventory) {  
    if (apple.getWeight() > 150) {  
      result.add(apple);  
    }  
  }  
  return result;  
}
```

after
```java
public static boolean isGreenApple(Apple apple) {  
  return "green".equals(apple.getColor());  
}  
  
public static boolean isHeavyApple(Apple apple) {  
  return apple.getWeight() > 150;  
}  
  
public static List<Apple> filterApples(List<Apple> inventory, Predicate<Apple> p) {  
  List<Apple> result = new ArrayList<>();  
  for (Apple apple : inventory) {  
    if (p.test(apple)) {  
      result.add(apple);  
    }  
  }  
  return result;  
}
```

method call
```java

List<Apple> greenApples = filterApples(inventory,FilteringApples::isGreenApple);  
List<Apple> heavyApples = filterApples(inventory,FilteringApples::isHeavyApple); 
```


### 프레디케이트(predicate)란 무엇인가?

앞에서 다룬 예제에서는 `Apple::isGreenApple` 메서드를 `filterApples`로 넘겨주었다(`filterApples`는 `Predicate<Apple>`를 파라미터로 받음). 수학에서는 인수로 값을 받아 `true`나 `false`를 반환하는 함수를 프레디케이트라고 한다.

## 1.3.3 메서드 전달에서 람다로

한 번만 사용할 메서드는 따로 정의를 구현할 필요가 없다.
하지만 람다가 몇 줄 이상으로 길어진다면(즉, 조금 복잡한 동작을 수행하는 상황) 익명 람다보다는 코드가 수행하는 일을 잘 설명하는 이름을 가진 메서드를 정의하고 메서드 참조를 활용하는 것이 바람직하다. 코드의 명확성이 우선시되어야 한다.

자바 8에서는 `filter`와 비슷한 동작을 수행하는 연산집합을 포함하는 새로운 스트림 API(컬렉션`Collection`과 비슷하며 프로그래머에게 더 익숙한 API)를 제공한다. 또한 컬렉션과 스트림 간에 변환할 수 있는 메서드(map, reduce 등)도 제공한다.

# 1. 4 스트림

컬렉션에서는 반복과 과정을 직접 처리해야 했다. 즉, `for-each` 루프를 이용해서 각 요소를 반복하면서 작업을 수행했다. 이런 방식의 반복을 외부 반복`external iteration` 이라고 한다. 반면 스트림 API를 이용하면 루프를 신경 쓸 필요가 없다. 스트림 API에서는 라이브러리 내부에 모든 데이터가 처리된다. 이와 같은 반복을 내부 반
복`internal iteration`이라고 한다. 

## 1.4.1 멀티스레딩은 어렵다

자바 8은 스트림 API(`java.util.stream`)로 '컬렉션을 처리하면서 발생하는 모호함과 반복적인 코드 문제' 그리고 '멀티코어 활용 어려움'이라는 두 가지 문제를 모두 해결했다. 

자주 반복되는 패턴으로 주어진 조건에 따라 데이터를 필터링 `filtering` 하거나 (예를 들면 무게에 따라 사과 선택),  데이터를 추출 `extracing` 하거나 (예를 들면 리스트에서 각 사과의 무게 필드 추출), 데이터를 그룹화`grouping` 하는 (예를 들면 숫자 리스트의 숫자를 홀수와 짝수로 그룹화함) 등의 기능이 있다.

또한 이러한 동작들을 쉽게 병렬화할 수 있는 점도 변화의 동기가 되었다. 예를 들어 두 CPU를 가진 환경에서 리스트를 필터링할 때 한 CPU는 앞부분을 처리하고, 다른 CPU는 리스트의 뒷부분을 처리하도록요청할 수 있다. 이 과정을 포킹`forking step` 라고 한다. 그리고 각각의 CPU는 자신이 맡은 절반의 리스트를 처리한다. 마지막으로 하나의 CPU가 두 결과를 정리한다.(구글 검색도 이와 같은 방식으로 작동하면서 빠르게 검색 결과를 제공한다. 물론 구글 검색은 두 개 이상의 프로세서를 사용한다.)

지금은 새로운 스트림 API도 기존의 컬렉션 API와 아주 비슷한 방식으로 동작한다고(즉, 두 방식 모두 순차적인 데이터 항목 접근 방식을 제공한다고) 간주할 것이다. 다만 컬렉션은 어떻게 데이터를 저장하고 접근할지에 중점을 두는 반면 스트림은 데이터에 어떤 계산을 할 것인지 묘사하는 것에 중점을 둔다는 점을 기억하자.

스트림은 스트림 내의 요소를 쉽게 병렬로 처리할 수 있는 환경을 제공하는 것이 핵심이다. 처음에는 이상하게 들릴 수 있겠지만 컬렉션을 필터링할 수 있는 가장 빠른 방법은 컬렉션을 스트림으로 바꾸고, 병렬로 처리한 다음에, 리스트로 다시 복원하는 것이다. 이전에도 언급했듯이 스트림과 람다 표현식을 이용하면 '병렬성을 공짜로' 얻을 수 있으며 리스트에서 무거운 사과를 순차적으로 또는 병렬로 필터링 할 수 있다.

다음은 순차 처리 방식의 코드다.
```java
List<Apple> heavyApples = inventory.stream().filter((Apple a) -> a.getWeight() > 150).collect(toList());
```

다음은 병렬 처리 방식의 코드다.
```java
List<Apple> heavyApples = inventory.parallelStream().filter((Apple a) -> a.getWeight() > 150).collect(toList());
```

### 자바의 병렬성과 공유되지 않는 가변 상태

흔히 사람들은 자바의 병렬성은 어렵고 `synchronized`는 쉽게 에러를 일으킨다고 생각한다. 자바 8은 어떤 요술방망이를 제공할까?

자바 8은 두 가지 요술방망이를 제공한다. 우선 라이브러리에서 분할을 처리한다. 즉, 큰 스트림을 병렬로 처리할 수 있도록 작은 스트림으로 분할한다. 또한 filter 같은 라이브러리 메서드로 전달된 메서드가 상호작용을 하지 않는다면 가변 공유 객체를 통해 공짜로 병렬성을 누릴 수 있다. 상호작용을 하지 않는다는 제약은 프로그래머 입장에서 상당히 자연스러운 일이다. 함수형 프로그래밍에서 함수형이란 '함수를 일급값으로 사용한다'라는 의미도 있지만 부가적으로 '프로그램이 실행되는 동안 컴포넌트 간에 상호작용이 일어나지 않는다'라는 의미도 포함한다.

# 1.5 디폴트 메서드와 자바 모듈

디폴트 메서드를 이용하면 기존의 코드를 건드리지 않고도 원래의 인터페이스 설계를 자유롭게 확장할 수 있다. 자바 8에서는 인터페이스 규격명세에 `default` 라는 새로운 키워드를 지원한다.

에를 들어 자바 8에서는 List에 직접 sort 메서드를 호출할 수 있다. 이는 자바 8의 List 인터페이스에 다음과 같은 디폴트 메서드 정의가 추가되었기 때문이다(이 디폴트 메서드는 정적 메서드인 Collections.sort를 호출한다).

```java
default void sort(Comparator<? super E> c) {
	Collections.sort(this, c);
}
```

따라서 자바 8 이전에는 List를 구현하는 모든 클래스가 sort를 구현해야 했지만 자바 8부터는 디폴트 sort를 구현하지 않아도 된다.

# 1.6 함수형 프로그래밍에서 가져온 다른 유용한 아이디어

자바 8에서는 `NullPointer` 예외를 피할 수 있도록 도와주는 `Optional<T>` 클래스를 제공한다. `Optional<T>`는 값을 갖거나 갖지 않을 수 있는 컨테이너 객체다.








